def notifyLINE(status) {
    def token = "TxyNyZcutXh1OEJkDuXu9hdXd2V7g06NLWFTcRf7qxz"
    def jobName = env.JOB_NAME +' '+env.BRANCH_NAME
    def buildNo = env.BUILD_NUMBER
    def stickerIdFailureList = ["2005","2007","2008","2019","2018","2020","2024","2022"]  
    def stickerIdSuccessList = ["1989","1993","1998","1991","1992","2003"]  
    def url = 'https://notify-api.line.me/api/notify'
    def stickerPackageId="446"
    Collections.shuffle stickerIdSuccessList
    stickerId=stickerIdSuccessList.first()
    if(status=="Failed"){
        Collections.shuffle stickerIdFailureList
        stickerId=stickerIdFailureList.first()
    }
    def message = "${env.JOB_NAME}\r\nMicroservice Name : ${params.MicroserviceName}\r\nVersion: ${params.Version}\r\nBranch: ${params.Branch}\r\nBuild and Deploy #${buildNo} ${status} \r\n"
    sh "curl ${url} -H 'Authorization: Bearer ${token}' -F 'message=${message}' -F 'stickerPackageId=${stickerPackageId}' -F 'stickerId=${stickerId}'"
}

pipeline {
   agent { node "DEV Site-140-13" }
   
    environment {
        scannerHome = tool 'SonarQ Scanner'
        dockerImage = ''
        HARBOR_CREDENTIAL = credentials('harbor')
    }
   
    stages {
        stage ('Prepare Job') {
            steps {
                script {
                    currentBuild.description = "Microservice Name : ${params.MicroserviceName}\nVersion: ${params.Version}\nBranch: ${params.Branch}"
                }
            }
        }
        stage('Git Pull'){
            steps {
                /*checkout scm: [$class: 'GitSCM', 
                    userRemoteConfigs: [[url: '${MicroservicePath}/${MicroserviceName}.git', 
                    credentialsId: 'gitlab100' ]], branches: [[name: '${Branch}']]], poll: false
                    */
                checkout([$class: 'GitSCM', 
                    branches: [[name: "${Branch}"]], 
                    doGenerateSubmoduleConfigurations: false, 
                    extensions: [],
                    submoduleCfg: [], 
                    userRemoteConfigs: [[credentialsId: "gitlab-jenkins-user-password", url: "${MicroservicePath}/${MicroserviceName}.git"]]])
            }
        }
        // stage('SonarQube Analysis'){
        //     steps {
        //     withSonarQubeEnv('SonarQuebe') { 
        //         sh 'npm install'
                
        //         sh "${scannerHome}/bin/sonar-scanner \
        //          -Dsonar.projectKey=olala-${MicroserviceName} \
        //          -Dsonar.sources=./src \
        //          -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info \
        //          -Dsonar.projectVersion=${Version}"
        //         }
        //     }
        // }
        // stage('Test'){
        //     steps {
        //         nvm(nvmInstallURL: 'https://raw.githubusercontent.com/creationix/nvm/v0.33.2/install.sh', 
        //         nvmIoJsOrgMirror: 'https://iojs.org/dist',
        //         nvmNodeJsOrgMirror: 'https://nodejs.org/dist', 
        //         version: "${Node_version}") {
        //             sh 'node -v'
        //             sh "npm install"
        //         }
        //     }
        // }
        // stage('Configuration Update'){
        //     steps {
        //         sh "cp docker-compose.prod.yml docker-compose.yml"
        //         sh "cp .env.prod .env"
        //     }
        // }
        stage('Build Image'){
            steps {
                script {
                    sh "docker build --no-cache -f deploy/Dockerfile -t ${ImageRegistryURL}/${MicroserviceName}:${Version} --build-arg BUILD_ID=pre_${params.MicroserviceName} ."
                }
            }
        }
        stage('Push image to Image Registry'){
            steps{
                script {
                    sh '''
                        echo $HARBOR_CREDENTIAL_PSW | \
                        docker login harbor.rvconnex.com -u $HARBOR_CREDENTIAL_USR --password-stdin
                    '''
                    sh "docker push ${ImageRegistryURL}/${MicroserviceName}:${Version}"
                }
            }
        }
        stage('Cleanup'){
            steps {
                echo 'Cleanup'
                //sh "docker rmi ${ImageRegistryURL}/${MicroserviceName}:${Version}"
                sh """
                  docker images \
                    | awk '{ print \$1,\$3 }' \
                    | grep ${params.MicroserviceName} \
                    | awk '{print \$2 }' \
                    | xargs -I {} docker rmi -f {}
                  """
                sh """
                  docker image prune -f \
                    --filter label=stage=builder \
                    --filter label=build=pre_${params.MicroserviceName}
                  """
            }
        }
    }
    post {   
         success {  
             notifyLINE("Succeed")
             //mail bcc: '', body: "<b>Jenkins Report</b><br>Project: ${env.JOB_NAME} <br>Build Number: ${env.BUILD_NUMBER} <br> URL de build: ${env.BUILD_URL}", cc: '', charset: 'UTF-8', from: 'pd.admin@rvconnex.com', mimeType: 'text/html', replyTo: '', subject: "successful CI: Project name -> ${env.JOB_NAME}", to: "kunchid.c@rvconnex.com";
         }  
         failure {  
             notifyLINE("Failed")
             //mail bcc: '', body: "<b>Jenkins Report</b><br>Project: ${env.JOB_NAME} <br>Build Number: ${env.BUILD_NUMBER} <br> URL de build: ${env.BUILD_URL}", cc: '', charset: 'UTF-8', from: 'pd.admin@rvconnex.com', mimeType: 'text/html', replyTo: '', subject: "ERROR CI: Project name -> ${env.JOB_NAME}", to: "kunchid.c@rvconnex.com";  
         }   
     }  
}